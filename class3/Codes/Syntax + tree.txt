#include <bits/stdc++.h>
using namespace std;

// ===== Tokens =====
enum class TokType {
    KW_INTEGER, KW_DEKHAO, KW_TE,
    IDENT, NUMBER,
    PLUS, MINUS, STAR, SLASH,
    LPAREN, RPAREN,
    END // per-line end
};

struct Token {
    TokType type;
    string lexeme;
    int line;
};

struct LexResult {
    vector<Token> tokens;
    vector<string> warnings;
};

// Simple lexer per line
class Lexer {
public:
    static LexResult lexLine(const string& s, int lineNo) {
        size_t i = 0;
        vector<Token> toks;
        vector<string> warns;
        auto push = [&](TokType t, string lx){ toks.push_back({t, lx, lineNo}); };

        auto isIdStart = [](char c){ return isalpha((unsigned char)c) || c=='_'; };
        auto isId = [](char c){ return isalnum((unsigned char)c) || c=='_'; };

        while (i < s.size()) {
            char c = s[i];
            if (isspace((unsigned char)c)) { ++i; continue; }

            if (isdigit((unsigned char)c)) {
                size_t j = i;
                while (j < s.size() && isdigit((unsigned char)s[j])) ++j;
                push(TokType::NUMBER, s.substr(i, j-i));
                i = j;
                continue;
            }

            if (isIdStart(c)) {
                size_t j = i;
                while (j < s.size() && isId(s[j])) ++j;
                string w = s.substr(i, j-i);

                string lw = w; for (auto& ch : lw) ch = (char)tolower(ch);
                if (lw == "integer" || lw == "interger") { // tolerate common typo
                    if (lw == "interger")
                        warns.push_back("Line " + to_string(lineNo) + ": 'interger' treated as 'integer'.");
                    push(TokType::KW_INTEGER, w);
                } else if (lw == "dekhao") {
                    push(TokType::KW_DEKHAO, w);
                } else if (lw == "te") {
                    push(TokType::KW_TE, w);
                } else {
                    push(TokType::IDENT, w);
                }
                i = j;
                continue;
            }

            switch (c) {
                case '+': push(TokType::PLUS, "+"); ++i; break;
                case '-': push(TokType::MINUS, "-"); ++i; break;
                case '*': push(TokType::STAR, "*"); ++i; break;
                case '/': push(TokType::SLASH, "/"); ++i; break;
                case '(': push(TokType::LPAREN, "("); ++i; break;
                case ')': push(TokType::RPAREN, ")"); ++i; break;
                default: {
                    warns.push_back("Line " + to_string(lineNo) + ": skipping unknown character '" + string(1,c) + "'.");
                    ++i;
                }
            }
        }
        toks.push_back({TokType::END, "", lineNo});
        return {toks, warns};
    }
};

// ===== AST =====
struct Node {
    virtual ~Node() = default;
};

struct Expr : Node {};
struct Stmt : Node {};

struct Number : Expr {
    int value;
    explicit Number(int v) : value(v) {}
};
struct Ident : Expr {
    string name;
    explicit Ident(string n) : name(std::move(n)) {}
};
struct Binary : Expr {
    string op;
    unique_ptr<Expr> left, right;
    Binary(string o, unique_ptr<Expr> l, unique_ptr<Expr> r)
        : op(std::move(o)), left(std::move(l)), right(std::move(r)) {}
};

struct Decl : Stmt {
    string name;
    int value;
    Decl(string n, int v) : name(std::move(n)), value(v) {}
};

struct Print : Stmt {
    unique_ptr<Expr> expr;
    explicit Print(unique_ptr<Expr> e) : expr(std::move(e)) {}
};

// ===== Parser (recursive descent, per-line statement) =====
class Parser {
public:
    explicit Parser(const vector<Token>& t) : toks(t), i(0) {}

    unique_ptr<Stmt> parseStatement(string& err) {
        if (match(TokType::KW_INTEGER)) return parseDecl(err);
        if (match(TokType::KW_DEKHAO))  return parsePrint(err);
        err = here() + "Expected 'integer' declaration or 'dekhao' print.";
        return nullptr;
    }

    bool atEnd() const { return peek().type == TokType::END; }

private:
    const vector<Token>& toks;
    size_t i;

    const Token& peek(size_t k=0) const { return toks[min(i+k, toks.size()-1)]; }
    bool check(TokType t, size_t k=0) const { return peek(k).type == t; }
    const Token& advance() { if (!atEnd()) ++i; return toks[i-1]; }
    bool match(TokType t) { if (check(t)) { advance(); return true; } return false; }

    string here() const { return "Line " + to_string(peek().line) + ": "; }

    unique_ptr<Stmt> parseDecl(string& err) {
        // integer IDENT te NUMBER
        if (!check(TokType::IDENT)) { err = here() + "Expected identifier after 'integer'."; return nullptr; }
        string name = advance().lexeme;

        if (!match(TokType::KW_TE)) { err = here() + "Expected 'te' after identifier."; return nullptr; }

        if (!check(TokType::NUMBER)) { err = here() + "Expected integer literal after 'te'."; return nullptr; }
        int val = stoi(advance().lexeme);

        if (!atEnd()) { err = here() + "Unexpected tokens after declaration."; return nullptr; }
        return make_unique<Decl>(name, val);
    }

    unique_ptr<Stmt> parsePrint(string& err) {
        // dekhao ( expr )
        if (!match(TokType::LPAREN)) { err = here() + "Expected '(' after 'dekhao'."; return nullptr; }
        auto e = parseExpr(err);
        if (!e) return nullptr;
        if (!match(TokType::RPAREN)) { err = here() + "Expected ')' after expression."; return nullptr; }
        if (!atEnd()) { err = here() + "Unexpected tokens after print statement."; return nullptr; }
        return make_unique<Print>(std::move(e));
    }

    // expr -> term (('+'|'-') term)*
    unique_ptr<Expr> parseExpr(string& err) {
        auto left = parseTerm(err);
        if (!left) return nullptr;
        while (check(TokType::PLUS) || check(TokType::MINUS)) {
            string op = advance().lexeme;
            auto right = parseTerm(err);
            if (!right) return nullptr;
            left = make_unique<Binary>(op, std::move(left), std::move(right));
        }
        return left;
    }

    // term -> factor (('*'|'/') factor)*
    unique_ptr<Expr> parseTerm(string& err) {
        auto left = parseFactor(err);
        if (!left) return nullptr;
        while (check(TokType::STAR) || check(TokType::SLASH)) {
            string op = advance().lexeme;
            auto right = parseFactor(err);
            if (!right) return nullptr;
            left = make_unique<Binary>(op, std::move(left), std::move(right));
        }
        return left;
    }

    // factor -> IDENT | NUMBER | '(' expr ')'
    unique_ptr<Expr> parseFactor(string& err) {
        if (check(TokType::IDENT)) {
            return make_unique<Ident>(advance().lexeme);
        }
        if (check(TokType::NUMBER)) {
            int v = stoi(advance().lexeme);
            return make_unique<Number>(v);
        }
        if (match(TokType::LPAREN)) {
            auto e = parseExpr(err);
            if (!e) return nullptr;
            if (!match(TokType::RPAREN)) { err = here() + "Expected ')' after sub-expression."; return nullptr; }
            return e;
        }
        err = here() + "Expected identifier, number, or '('";
        return nullptr;
    }
};

// ===== AST Printing =====
struct ASTPrinter {
    static void print(const vector<unique_ptr<Stmt>>& program) {
        cout << "=== Syntax Tree (pretty) ===\n";
        int idx = 1;
        for (auto& s : program) {
            cout << "Stmt " << idx++ << ":\n";
            printStmt(*s, 2);
        }
    }

    static void printStmt(const Stmt& s, int indent) {
        auto pad = string(indent, ' ');
        if (auto d = dynamic_cast<const Decl*>(&s)) {
            cout << pad << "Decl(integer)\n";
            cout << pad << "  name: " << d->name << "\n";
            cout << pad << "  value: " << d->value << "\n";
        } else if (auto p = dynamic_cast<const Print*>(&s)) {
            cout << pad << "Print(dekhao)\n";
            cout << pad << "  expr:\n";
            printExpr(*p->expr, indent + 4);
        } else {
            cout << pad << "<unknown stmt>\n";
        }
    }

    static void printExpr(const Expr& e, int indent) {
        auto pad = string(indent, ' ');
        if (auto n = dynamic_cast<const Number*>(&e)) {
            cout << pad << "Number(" << n->value << ")\n";
        } else if (auto id = dynamic_cast<const Ident*>(&e)) {
            cout << pad << "Ident(" << id->name << ")\n";
        } else if (auto b = dynamic_cast<const Binary*>(&e)) {
            cout << pad << "BinaryOp(" << b->op << ")\n";
            cout << pad << "  left:\n";
            printExpr(*b->left, indent + 4);
            cout << pad << "  right:\n";
            printExpr(*b->right, indent + 4);
        } else {
            cout << pad << "<unknown expr>\n";
        }
    }
};

// ===== Graphviz DOT generator =====
struct DOT {
    int nextId = 0;
    ofstream out;

    explicit DOT(const string& path) : out(path) {
        out << "digraph AST {\n";
        out << "  node [shape=box];\n";
    }
    ~DOT() { out << "}\n"; }

    int node(const string& label) {
        int id = nextId++;
        out << "  n" << id << " [label=\"" << escape(label) << "\"];\n";
        return id;
    }
    void edge(int a, int b, const string& elabel = "") {
        out << "  n" << a << " -> n" << b;
        if (!elabel.empty()) out << " [label=\"" << escape(elabel) << "\"]";
        out << ";\n";
    }
    static string escape(string s) {
        for (auto& c : s) if (c=='"') c='\'';
        return s;
    }

    int emitStmt(const Stmt& s) {
        if (auto d = dynamic_cast<const Decl*>(&s)) {
            int r = node("Decl\\n(integer)");
            int n1 = node("name: " + d->name);
            int n2 = node("value: " + to_string(d->value));
            edge(r, n1);
            edge(r, n2);
            return r;
        } else if (auto p = dynamic_cast<const Print*>(&s)) {
            int r = node("Print\\n(dekhao)");
            int e = emitExpr(*p->expr);
            edge(r, e, "expr");
            return r;
        }
        return node("<unknown stmt>");
    }

    int emitExpr(const Expr& e) {
        if (auto n = dynamic_cast<const Number*>(&e)) {
            return node("Number\\n" + to_string(n->value));
        } else if (auto id = dynamic_cast<const Ident*>(&e)) {
            return node("Ident\\n" + id->name);
        } else if (auto b = dynamic_cast<const Binary*>(&e)) {
            int r = node("BinaryOp\\n" + b->op);
            int L = emitExpr(*b->left);
            int R = emitExpr(*b->right);
            edge(r, L, "left");
            edge(r, R, "right");
            return r;
        }
        return node("<unknown expr>");
    }
};

int main() {
    ifstream fin("input.txt");
    if (!fin) {
        cerr << "Error: could not open input.txt\n";
        return 1;
    }

    vector<unique_ptr<Stmt>> program;
    vector<string> warnings;
    string line;
    int lineNo = 1;

    cout << "=== Lexical Tokens ===\n";
    while (getline(fin, line)) {
        string trimmed = line;
        // trim
        auto lpos = trimmed.find_first_not_of(" \t\r\n");
        auto rpos = trimmed.find_last_not_of(" \t\r\n");
        if (lpos == string::npos) { ++lineNo; continue; }
        trimmed = trimmed.substr(lpos, rpos - lpos + 1);

        auto L = Lexer::lexLine(trimmed, lineNo);
        for (auto& w : L.warnings) warnings.push_back(w);

        // print tokens
        for (auto &t : L.tokens) {
            if (t.type == TokType::END) continue;
            cout << "Line " << t.line << " -> " << t.lexeme << "\n";
        }

        // parse one statement per non-empty line
        Parser P(L.tokens);
        string err;
        auto stmt = P.parseStatement(err);
        if (!stmt) {
            cerr << "Syntax error: " << err << "\n";
            return 2;
        }
        program.push_back(std::move(stmt));

        ++lineNo;
    }

    // pretty print AST
    cout << "\n";
    ASTPrinter::print(program);

    // Graphviz file
    DOT dot("ast.dot");
    int idx = 1;
    vector<int> roots;
    for (auto& s : program) {
        int r = dot.emitStmt(*s);
        roots.push_back(r);
    }
    // Add an artificial Program node to connect statements
    int prog = dot.node("Program");
    for (size_t k=0; k<roots.size(); ++k) {
        dot.edge(prog, roots[k], "stmt" + to_string((int)k+1));
    }

    // print warnings if any
    if (!warnings.empty()) {
        cout << "\n=== Warnings ===\n";
        for (auto& w : warnings) cout << w << "\n";
    }

    return 0;
}
